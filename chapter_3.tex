\chapter{Opis problemu}

\section{Architektura Android}
Architektura Android przez wielu opisywana jest jako \textit{Java on Linux}, czyli programowanie w Javie pod Linuksem. Jednakże jest to stwierdzenie zbyt ogólne, biorąc pod uwagę złożoność całej platformy. Całość systemu zawiera bowiem w sobie komponenty, które układają się w pięć głównych warstw: \textit{Android applications}, \textit{the Android Framework}, \textit{the Dalvik virtual machine}, \textit{user-space native code} oraz \textit{Linux kernel}\cite{bib:hacker:handbook}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=15cm]{imgs/ch3_android_architecture_1.jpg}
    \caption
{Przegląd architektury Android. Źródło: Karim Yaghmour of Opersys Inc., \url{http://http://www.slideshare.net/opersys/inside-androids-ui}}
    \label{fig:ch3_android_architecture_1}
\end{figure} 

Aplikacje Android pozwalają developerom rozszerzać i ulepszać funkcjonalność urządzeń, bez konieczności sięgania do niższych warstw systemu. W zamian framework Androida dostarcza developerom bogate środowisko użytkownika, które pozwala na dostęp do różnych udogodnień, jakie urządzenie z tym systemem jest w stanie programiście zaoferować. Jest to swoiste połączenie pomiędzy aplikacjami a wirtualną maszyną Dalvika, które zezwala na konfigurowanie interfejsu użytkownika (UI\footnote{User Interface}), dostęp do baz danych oraz przekazywanie informacji pomiędzy poszczególnymi komponentami aplikacji.

Zarówno aplikacje jak i opisywany \textit{framework} napisane są w Javie i wykonywane na wirtualnej maszynie Dalvika (\textit{DalvikVM}). Jest to specjalnie zaprojektowana wirtualna maszyna z własnym kodem bajtowym, zoptymalizowana pod jądro Linuxa i pozwalająca na uruchamianie aplikacji androidowych. Niestety, nie wszystkie biblioteki wykorzystane przy jej tworzeniu udostępnione są na zasadzie wolnych licencji.

Natywne elementy kodu Androida zawierają usługi systemowe, usługi sieciowe (takie jak \textit{DHCP} i \textit{wpa\_supplicant}) oraz różnego rodzaju biblioteki, między innymi \textit{WebKit} i \textit{OpenSSL}. 

Najniższą warstwą, a zarazem podstawą systemu Android jest jądro Linuxa. Android dokonał licznych uzupełnień i zmian w jego źródłach, z których niektóre mają swoje negatywne konsekwencje dla bezpieczeństwa (ale nie będziemy zajmować się tym w ramach tej publikacji). Sterowniki znajdujące się w jądrze systemu zapewniają również dodatkowe funkcje, takie jak dostęp do kamery, sieci Wi-Fi oraz dostęp do innych urządzeń sieciowych. Szczególnie godny uwagi jest sterownik \textit{Binder}, który realizuje komunikację między procesami\cite{bib:hacker:handbook} (IPC\footnote{Inter-Process Communication}).

\section{Standardowe podejście przy tworzeniu aplikacji}
W większości przypadków aplikacje z przeznaczeniem dla systemu Android pisane są według następującego schematu:

\begin{figure}[!htb]
    \centering
    \includegraphics[width=15cm]{imgs/ch3_opis_problemu_1.png}
    \caption
{Podejście „standardowe” przy tworzeniu aplikacji dla systemu Android}
    \label{fig:opis_problemu}
\end{figure} 

Czyli, na najniższej warstwie mamy Android SDK\footnote{Software Development Kit}  i na niej budujemy kolejne warstwy. Każda z kolejnych warstw naszego oprogramowania korzysta z warstwy poniżej, a co za tym idzie, dziedziczy również zależności z warstwy Android SDK. Analizując taką strukturę aplikacji dostępnych pod Androidem możemy zaobserwować, że w wielu z nich:
\begin{itemize}
\item
nie jest zachowana zasada pojedynczej odpowiedzialności,
\item
warstwa odpowiedzialna za logikę domenową jest pomieszana z warstwą UI (User Interface),
\item
logika UI jest pomieszana z asynchronicznym pobieraniem danych,
\item
funkcje \textit{callback\footnote{Wywołanie zwrotne (ang. callback) jest to technika programowania będąca odwrotnością wywołania funkcji. Zwykle korzystanie z właściwości konkretnej biblioteki polega na wywołaniu funkcji (podprogramów) dostarczanych przez tę bibliotekę. W tym przypadku jest odwrotnie: użytkownik jedynie rejestruje funkcję do późniejszego wywołania, natomiast funkcje biblioteki wywołają ją w stosownym dla siebie czasie. Źródło: Wikipedia}} możemy znaleźć dosłownie wszędzie,
\item
elementy warstwy UI: Activity i Fragmenty potrafią mieć tysiące linii kodu,
\item
w większości plików aplikacji na każdej warstwie odwołujemy się do środowiska Android (\texttt{import android.*})
\item
i ostatnie, ale najważniejsze z punktu widzenia tej pracy: jeżeli w kodzie źródłowym szukamy zestawu unit testów – możemy się rozczarować.
\end{itemize}

Spowodowane jest to dwoma czynnikami: pierwszy to trudność w wyodrębnieniu obszarów testowych z powodu zbyt dużego sprzężenia między warstwami (\textit{couplingu}), a drugi – pracochłonność w pisaniu testów. Jeżeli granica pomiędzy kolejnymi warstwami oprogramowania nie jest jasno wyznaczona, liczba testów do zaprojektowania rośnie drastycznie.

\section{Trudności w testowaniu aktualnej struktury aplikacji}
\label{testowanie_starej_struktury}

Weźmy dwie funkcjonalności: funkcjonalność \textbf{A} opisaną za pomocą kodu z jedną instrukcją warunkową \textit{„if”}, oraz funkcjonalność \textbf{B}, w której mamy dwie zależne od siebie instrukcje \textit{„if”}, czyli cztery możliwe decyzje programowe. Testując te funkcjonalności razem (z powodu sprzężenia nie mamy innego wyjścia) musimy wykonać łącznie \textit{2 * 4 = 8} testów. Testy te równocześnie przestają być testami jednostkowymi, gdyż łączą w sobie kilka funkcjonalności i stają się przez to testami integracyjnymi. Testując natomiast te funkcjonalności osobno, wykonamy \textit{2 + 4 = 6} unit testów. W tym przykładzie oczywiście nie widać zbyt wielkiej optymalizacji, ale w aplikacjach z kodem, który dostarcza setki czy tysiące decyzji, różnica będzie znacząca.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=10cm]{imgs/ch3_przyklad_testowania_klas.png}
    \caption
{Różnice w testowaniu klas osobno i razem. \textit{"Integrated Tests are a Scam"} - schemat autorstwa J.B. Rainsbergera. Źródło: \url{https://vimeo.com/80533536)}}
    \label{fig:testowanie_klas}
\end{figure} 

Również w przypadku architektury aplikacji Android, jeżeli zachodzi konieczność testowania każdej klasy lub pojedynczej funkcji w powiązaniu z \textit{Android SDK}, liczba testów jednostkowych zauważalnie wzrośnie.

\section{Idealna i odwrócona piramida testowania}
Z doświadczenia własnego autora oraz jego kolegów testerów można wywnioskować, że jeżeli chcemy aplikację przetestować zaczynając od testów integracyjnych zamiast od testów jednostkowych, nakład pracy będzie zdecydowanie większy, niż gdy zastosujemy schemat standardowy, czyli zaczynając od \textit{Unit Tests}, kontynuując poprzez testy integracyjne, następnie systemowe, a kończąc na akceptacyjnych (etapów może być więcej). 

Pozbawiając się możliwości zastosowania testów jednostkowych na wczesnym etapie projektu z powodu źle zaprojektowanej struktury aplikacji, ryzykujemy utratę jakości, a co za tym idzie - utratę zaufania klientów do naszego oprogramowania. Idealna piramida testowania, spopularyzowana przez Mike’a Cohna \footnote{Mike Cohn jest jednym twórców metodologii tworzenia oprogramowania Scrum. Jest jednym z założycieli Scrum Alliance oraz właścicielem Mountain Goat Software, firmy, która oferuje szkolenia na Scrum i technik Agile.}  w książce „Succeeding with Agile” \cite{bib:cohn:agile}, przedstawiona została na rysunku \ref{fig:idealna_piramida}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=8cm]{imgs/ch3_idealna_piramida.png}
    \caption
{Idealna piramida testowania według Mike'a Cohna\cite{bib:cohn:agile}}
    \label{fig:idealna_piramida}
\end{figure} 

\newpage
Z powyższego schematu wynika, że idealnie byłoby, gdyby wszystkie etapy testów zostały zautomatyzowane (wszystkie, z wyjątkiem manualnych testów akceptacyjnych, ale w idealnym świecie powinno być ich tak mało, że ich automatyzacja nie miałaby większego sensu). Oczywiście piramida ta może przybierać różne formy, poziomów testowania może być więcej lub mniej, mogą być one zautomatyzowane lub nie, ale idea jest cały czas ta sama: najwięcej przypadków testowych powinno być na najniższym poziomie. Powinny być one również najprostsze do zaprojektowania. Im dalsza faza projektu, tym testy stają się bardziej pracochłonne, a koszt usunięcia znalezionego błędu wyższy, do czego autor nawiązał już w tabeli \ref{tab:koszty_bledu}.

Analizując aktualną strukturę większości aplikacji androidowych, schemat ten wygląda jednak tak jak na rysunku \ref{fig:odwrocona_piramida}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=8cm]{imgs/ch3_odwrocona_piramida.png}
    \caption
{Software Testing Ice Cream AntiPatern. Źródło: \url{watirmelon.com}}
    \label{fig:odwrocona_piramida}
\end{figure} 

\newpage
Na rysunku \ref{fig:odwrocona_piramida} widać, że z powodu zbyt dużego \textit{couplingu} unit testy zastąpione zostają testami integracyjnymi, a najwięcej przypadków testowych wykonywanych jest na interfejsie użytkownika (w czym znacznie pomagają frameworki testowe pozwalające na zautomatyzowanie pewnych czynności, nagranie makr według specyfikacji lub \textit{„user stories”}) oraz testy manualne.

Autor nie zaprzecza, że tym sposobem nie da się dobrze przetestować aplikacji, szczególnie jeżeli zastosujemy taktyki testowania opisane w rozdziale \ref{testowalnosc}. Jak powszechnie wiadomo, testowanie gruntowne nie jest możliwe, jakiejkolwiek metody nie użylibyśmy. Lecz ryzyko znalezienia błędu na dalszym etapie projektu jest w tym przypadku znacznie większe niż w przypadku oprogramowania o usystematyzowanej strukturze, a co za tym idzie – koszty jego usunięcia są również znacznie wyższe.

Okazuje się, że strukturę aplikacji Android da się jednak przeprojektować tak, aby ułatwić życie zarówno programistom jak i testerom. Propozycja zmiany struktury aplikacji Android zaproponowana została w rozdziale \ref{clean_architecture}

\section{Przyczyny rezygnacji z testów jednostkowych}
\label{testy_jednostkowe_brak}
Trudna w testowaniu struktura aplikacji to jednak nie jedyna przyczyna niedostatecznej ilości testów jednostkowych, a nawet ich braku w procesie tworzenia aplikacji. Przyczyn takiej sytuacji może być wiele, a najważniejsze z nich, zdaniem autora, to:
\begin{itemize}
\item
Niedostateczna znajomość języka programowania wśród programistów

Jeżeli programista, nawet dobry, został zmuszony przez sytuację do poznawania nowego języka programowania, to w pierwszej kolejności chciałby, aby jego kod się kompilował, a program zaczął działać. Jeżeli zaczyna pisać testy, to znaczy, że ma na to czas i nie musi zagłębiać się w techniki konfiguracji kompilatora, czy środowiska programistycznego. 

\item
Słaba znajomość narzędzi testowych

Jeżeli programista nie doskonali się w temacie projektowania testów, nie poznaje narzędzi testowych, które mogą spowodować, że testowanie stanie się łatwe i przyjemne, szybko zniechęci się już przy pierwszej próbie napisania trudniejszego testu, czy próbie \textit{zamockowania} jednego z interfejsów.

\item
Niska jakość kodu źródłowego

Kiepsko zaprojektowany kod i niezbyt optymalnie zaprojektowana architektura systemowa powoduje, że nie ma możliwości w rozsądnym czasie przygotować zestawu testów. To powoduje, że firmy rezygnują z  testów jednostkowych na rzecz testów integracyjnych i systemowych, co pokazane zostało na rysunku \ref{fig:odwrocona_piramida}.

\item
Brak czasu na testy

W dzisiejszych czasach koszty projektów informatycznych są zwykle ograniczone i menedżerowie niechętnie godzą się na dodatkowe aktywności, jeżeli wiąże się to z przekroczeniem pewnych ram czasowych. A programiści starają się wykorzystywać cały swój czas aż do \textit{deadline'ów} na "ulepszanie" kodu, co skutkuje brakiem czasu na testy jednostkowe.

\item
Przekonanie programistów o własnej nieomylności

Człowiek jest omylny i popełnia błędy, do czego już autor nawiązał w rozdziale \ref{testowalnosc}. Niektórzy programiści nie chcą jednak przyjąć tego do wiadomości i upierają się przy stwierdzeniach, że testy do ich kawałka kodu źródłowego nie są potrzebne.
\end{itemize}

Należy zastanowić się, czy zastosowanie jednej z taktyk zwinnych, w tym przypadku TDD, pozwoliłoby usystematyzować pracę nad projektem i usunąć wszystkie powyższe przyczyny.

\section{Pielęgnowalność aplikacji Android}
\label{pielegnowalnosc_aplikacji}
W realnym świecie niestety bardzo rzadko mamy możliwość tworzenia aplikacji od początku. W większości przypadków programiści muszą borykać się z kodem, który ktoś już kiedyś napisał, a dotyczy to w zasadzie wszystkich większych projektów informatycznych. Weźmy na przykład taką aplikację jak \textit{Gmail}. Wychodzą ciągle nowe wersje, ale trudno wyobrazić sobie sytuację, że któraś z nich została po prostu napisana od nowa. W takich przypadkach mamy do czynienia z tzw. \textbf{kodem zastanym}.

O ile kod pisany był w sposób przejrzysty, dobrzy programiści są w stanie dobudować nowe części aplikacji, nawet nie mając dokumentacji do starszej części. Wiele firm programistycznych stosuje podejście, że sam kod programu jest zarówno jego dokumentacją. Rozsądne nadawanie nazw zmiennym oraz umieszczanie rzeczowych komentarzy pozwala programistom zrozumieć swoich poprzedników, a automatycznym narzędziom w stylu \textit{JavaDoc\footnote{Javadoc – narzędzie automatycznie generujące dokumentację na podstawie zamieszczonych w kodzie źródłowym znaczników w komentarzach. Javadoc został stworzony specjalnie na potrzeby języka programowania Java przez firmę Sun Microsystems. Źródło: Wikipedia}} wygenerować całkiem wyczerpującą dokumentację.

Gorsza sytuacja jest z testowaniem. Jeżeli produkt nie był tworzony z zastosowaniem TDD, praca jaką należałoby wykonać przy pisaniu unit testów do gotowego kodu może być ogromna. Ponadto istnieje ryzyko, że tester chcąc sprostać wymaganiom osób zarządzających projektem będzie tak pisał testy jednostkowe, aby pokrywały jak największą część kodu, niekoniecznie przy tym wnosząc jakoś wartość w sprawdzenie niezawodności aplikacji.

Jedno z możliwych rozwiązań zaproponowane zostało w rozdziale \ref{legacy_code}