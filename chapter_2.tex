\chapter{Testowalność oprogramowania}
\label{testowalnosc}
\section{Pojęcie testowalności i~pielęgnowalności \newline oprogramowania}
Termin „testowalność oprogramowania” \footnote{Definicja testowalności według standardu ISO9126}  według definicji ISTQB \footnote{International Software Qualification Board}  i~ISO9126, to właściwość tego oprogramowania umożliwiająca testowanie go po zmianach. Termin ten ściśle powiązany jest także z~innym pojęciem ze słownika testerskiego – pielęgnowalnością. Pielęgnowalność\footnote{Definicja pielęgnowalności według ISTQB} definiowana jest jako łatwość, z~którą oprogramowanie może być modyfikowane w~celu naprawy defektów, dostosowania do nowych wymagań, modyfikowane w~celu ułatwienia przyszłego utrzymania lub dostosowania do zmian zachodzących w~jego środowisku.

\section{Czy testowanie jest potrzebne?}
\label{czy_testowanie_potrzebne}
Człowiek, jako istota żywa i~omylna, może popełnić podczas pracy \textit{błąd}, czyli inaczej – \textit{pomyłkę}. Pomyłka w~pracy programisty może skutkować pojawieniem się \textit{defektu} (usterki, pluskwy) w~kodzie programu, bądź w~dokumentacji. Jeżeli kod programu, który posiada w~sobie taki defekt, zostanie wykonany, system może nie zrobić tego, do czego został zaprojektowany, lub wykonać to niezgodnie z~założeniami. Czyli inaczej rzecz ujmując, ulegnie \textit{awarii}. 

Defekty powstają, ponieważ ludzie są omylni, ale pomyłka człowieka, to nie jedyny powód awarii systemów. Mogą one być również spowodowane przez warunki środowiskowe, takie jak promieniowanie, pole magnetyczne i~elektryczne, czy nawet zanieczyszczenia środowiska.

Czy testowanie powoduje całkowite wyeliminowanie awarii systemów? Na pewno nie, ale pozwala je drastycznie ograniczyć. Za pomocą zestawu testów można zmierzyć jakość oprogramowania wyrażoną przez ilość znalezionych usterek oraz budować zaufanie do jakości oprogramowania, jeżeli testerzy znajdują ich mało, bądź nie znajdują ich wcale.

Należy jednak pamiętać, że testowanie samo w~sobie nie poprawia jakości oprogramowania. Dopiero umiejscowienie defektu w~kodzie programu (zdebugowanie) oraz naprawa tego błędu przez programistę poprawi jakość. Tabela \ref{tab:koszty_bledu} przedstawia poglądowo, jak testowanie na poszczególnych etapach wytwarzania oprogramowania może wpłynąć na koszty projektu.

\begin{table}[]
\centering
\caption{Koszty znalezienia błędu na poszczególnych etapach projektu}
\label{tab:koszty_bledu}
\begin{tabular}{|l|l|}
\hline
\textbf{Błąd znaleziony podczas} & \textbf{Szacowany koszt} \\ \hline
Projektowania & 1 PLN	\\ \hline
Inspekcji (przeglądu) & 10 PLN	\\ \hline
W początkowej fazie produkcji & 100 PLN	\\ \hline
Podczas testów systemowych & 1000 PLN	\\ \hline
Po dostarczeniu produktu na rynek & 10000 PLN	\\ \hline
Kiedy produkt musi zostać wycofany z~rynku & 100000 PLN	\\ \hline
Kiedy produkt musi zostać wycofany z~rynku po wyroku sądowym & 1000000 PLN	\\ \hline
\end{tabular}
\end{table}

Z zestawienia jasno wynika, że praca testerów nie zaczyna się dopiero gdy program już jest napisany przez programistów, a~zaczyna się już w~najwcześniejszej fazie projektu, na etapie projektowania.

\section{Rodzaje testów}
Proces testowania może zostać wprowadzony na każdym etapie tworzenia aplikacji, w~zależności od wybranej strategii testu. Jednakże, jak już zostało wspomniane w~podrozdziale \ref{czy_testowanie_potrzebne}, najlepiej jest rozpoczynać testowanie tak szybko jak to jest możliwe, w~możliwie najwcześniejszym stadium projektu. Nawet jeżeli nie wszystkie wymagania systemowe zostały uzgodnione, a~proces pisania oprogramowania się jeszcze nie rozpoczął. Już sam etap tworzenia dokumentacji i~wymagań, czy to na poziomie klienta, systemowym, czy programowym, powinien zostać poddany testowaniu. Pozwala to już na początku uniknąć błędów mogących wpływać na rozwój projektu przez długi czas.

Rozpoznaje się kilka poziomów testowania, w~zależności od modelu zarządzania projektem. Rozważając model V, który jest przedstawiony na schemacie \ref{fig:model_v}, wyróżnić można cztery główne  z~punktu widzenia testowalności obszary:

\begin{itemize}
\item
testy jednostkowe;
\item
testy integracyjne;
\item
testy systemowe;
\item
testy akceptacyjne.

\end{itemize}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=12cm]{imgs/ch2_model_v_pl.jpg}
    \caption{Model V - najpopularniejszy model zarządzania projektem informatycznym (\textit{V~model}) \cite{website:android:modelv}.}
    \label{fig:model_v}
\end{figure} 

\subsection{Testy jednostkowe (modułowe)}

Według \cite{bib:sylabus:foundation}, testy modułowe polegają na wyszukiwaniu błędów i~weryfikacji funkcjonalności oprogramowania (np. modułów, klas), które można testować oddzielnie. Testowanie może być wykonywane w~izolacji od reszty systemu, w~zależności od kontekstu cyklu rozwoju oprogramowania i~od samego systemu. Podczas testów można używać zaślepek, sterowników testowych oraz symulatorów. 

Mogą one zawierać testy funkcjonalności oraz niektórych atrybutów niefunkcjonalnych, takich jak stopień wykorzystania zasobów (np. wycieków pamięci) lub odporności. Wlicza się w~nie również testy strukturalne - pokrycia linii kodu, decyzji lub gałęzi. Do projektowania przypadków testowych bardzo przydatna jest specyfikacja fumkcji. Wtedy jest możliwość zaprojektowania testów zanim zostanie napisany kod programu (tzw. "wytwarzanie sterowane testowaniem" - \textit{Test Driven Development}, opisane szerzej w~sekcji \ref{test_driven_development}). Testy modułowe zwykle wykonuje się mając dostęp do kodu źródłowego i~przy wsparciu środowiska rozwojowego (np. bibliotek do testów jednostkowych, narzędzi do debagowania). Testy jednostkowe w~praktyce zwykle angażują też programistę, który jest autorem kodu. Usterki są usuwane jak tylko zostaną wykryte, bez systemu formalnego nimi zarządzania.

%Najczęściej wykorzystywanym środowiskiem testowym dla Unit Testów w Javie jest \textit{JUnit}. To proste i~użyteczne narzędzie, pozwalające automatyzować testy jednostkowe, zostało zaprojektowane przez Ericha Gamma\footnote{Erich Gamma - szwajcarski informatyk, współautor książki "Wzorce projektowe: elementy oprogramowania obiektowego wielokrotnego użytku". Wspólnie z~Kentem Beckiem napisał narzędzie do tworzenia testów jednostkowych JUnit. Rozwijał także środowisko Eclipse.} i~Kenta Becka i~wydane na licencji \textit{open source}\cite{website:opensource}.

%Głównie badaniem tego rodzaju testów autor zajmował się będzie w~części doświadczalnej pracy magisterskiej, w~rozdziale \ref{analiza_testow}.

\subsection{Testy integracyjne}

Testy integracyjne służą do sprawdzania interfejsów pomiędzy modułami, interakcji z~innymi częściami systemu (takimi jak system operacyjny, system plików i~sprzęt) oraz zależności pomiędzy systemami.

Wykonuje je się zwykle, jeżeli tylko jest możliwość przetestowania integracji gotowych już modułów, przetestowanych testami jednostkowymi. Pojęcie testowania integracyjnego można rozszerzyć również na testowanie integracji pomiędzy różnymi systemami, a~nawet produktami różnych producentów \cite{bib:sylabus:foundation}.

\subsection{Testy systemowe}

Testy systemowe zajmują się zachowaniem produktu lub systemu. Zakres takich testów powinien być jasno określony w~głównym planie testów oraz w~planach poszczególnych poziomów weryfikacji. Testy systemowe mogą zawierać testy oparte na ryzyku lub wymaganiach, procesie biznesowym, przypadkach użycia lub wysokopoziomowych opisach słownych i~modelach zachowania systemu, interakcji z~systemem operacyjnym i~zasobami systemowymi.

Dąży się do tego, aby środowisko testowe w~przypadku tego typu weryfikacji było maksymalnie zbliżone do środowiska docelowego, w~którym projektowana aplikacja ma działać. Optymalnie byłoby pokryć wszystkie możliwe konfiguracje sprzętowe, aczkolwiek z~wielu powodów, głównie finansowych, firmy skupiają się na najczęściej wykorzystywanych przez użytkowników urządzeniach \cite{bib:sylabus:foundation}. 

\subsection{Testy akceptacyjne}
\label{testy_akceptacyjne}

Celem testów akceptacyjnych jest nabranie zaufania do systemu, jego części lub pewnych atrybutów niefunkcjonalnych. Wyszukiwanie usterek nie jest głównym celem tego rodzaju testowania. Testy akceptacyjne mogą oceniać gotowość systemu do wdrożenia i~użycia, chociaż nie muszą być ostatnim poziomem testowania. Na przykład może po nich następować testowanie integracji systemów w~większej skali.

Odpowiedzialność za testy akceptacyjne, w~przeciwieństwie do testów opisanych w~poprzednich paragrafach, leży po stronie klientów. Zwykle testy akceptacyjne dzieli się na dwa etapy: testy \textit{alfa} oraz \textit{beta}. Testy \textit{alfa} przeprowadzane są przez przyszłych użytkowników w~siedzibie producenta, natomiast \textit{beta} - w~środowisku docelowym. W~praktyce producenci oprogramowania przekazują darmowe wersje swoich aplikacji o~ograniczonych możliwościach, oczekując w~zamian od użytkowników raportowania błędów lub propozycji usprawnień, bądź uzyskując to raportowanie automatycznie, kiedy aplikacja sama wysyła do producenta informację o~zaistniałych defektach \cite{bib:sylabus:foundation}.

\section{Idealna i~odwrócona piramida testowania}
\label{piramida_testowania}
Bazując na \cite{bib:android:testing:learning} można wywnioskować, że jeżeli aplikacja ma być przetestowana zaczynając od testów integracyjnych zamiast od testów jednostkowych, nakład pracy będzie zdecydowanie większy, niż gdy zastosowany zostanie schemat standardowy, czyli zaczynając od \textit{Unit Tests}, kontynuując poprzez testy integracyjne, następnie systemowe, a~kończąc na akceptacyjnych (etapów może być więcej). 

Pozbawiając się możliwości zastosowania testów jednostkowych na wczesnym etapie projektu z~powodu źle zaprojektowanej struktury aplikacji, ryzykujemy utratę jakości, a~co za tym idzie - utratę zaufania klientów do oprogramowania. Idealna piramida testowania, spopularyzowana przez Mike’a Cohna \footnote{Mike Cohn jest jednym twórców metodologii tworzenia oprogramowania Scrum. Jest jednym z~założycieli Scrum Alliance oraz właścicielem Mountain Goat Software, firmy, która oferuje szkolenia na Scrum i~technik Agile \cite{website:wikipedia}.} \cite{bib:cohn:agile}, przedstawiona została na rysunku \ref{fig:idealna_piramida}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=7cm]{imgs/ch3_idealna_piramida.jpg}
    \caption
{Idealna piramida testowania według Mike'a Cohna \cite{bib:cohn:agile}.}
    \label{fig:idealna_piramida}
\end{figure} 

\newpage
Wynika z~tego, że idealnie byłoby, gdyby wszystkie etapy testów zostały zautomatyzowane (wszystkie, z~wyjątkiem manualnych testów akceptacyjnych, ale w~idealnym świecie powinno być ich tak mało, że ich automatyzacja nie miałaby większego sensu). Oczywiście piramida ta może przybierać różne formy, poziomów testowania może być więcej lub mniej, mogą być one zautomatyzowane lub nie, ale idea jest cały czas ta sama: najwięcej przypadków testowych powinno być na najniższym poziomie. Powinny być one również najprostsze do zaprojektowania. Im dalsza faza projektu, tym testy stają się bardziej pracochłonne, a~koszt usunięcia znalezionego błędu wyższy, do czego autor nawiązał już w~tabeli \ref{tab:koszty_bledu}.

Analizując aktualną strukturę większości aplikacji androidowych, schemat ten przedstawia się tak, jak na rysunku \ref{fig:odwrocona_piramida}.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=7cm]{imgs/ch3_odwrocona_piramida.jpg}
    \caption
{Podejście klasyczne do testów, czyli odwrócona piramida testowania (\textit{Ice Cream AntiPatern}) \cite{website:piramidatestow}.}
    \label{fig:odwrocona_piramida}
\end{figure} 

Na rysunku \ref{fig:odwrocona_piramida} widać, że z~powodu zbyt dużego \textit{couplingu} unit testy zastąpione zostają testami integracyjnymi, a~najwięcej przypadków testowych wykonywanych jest na interfejsie użytkownika (w czym znacznie pomagają frameworki testowe pozwalające na zautomatyzowanie pewnych czynności, nagranie makr według specyfikacji lub \textit{„user stories”}) oraz testy manualne.

Autor nie zaprzecza, że tym sposobem nie da się dobrze przetestować aplikacji, szczególnie jeżeli zastosujemy taktyki testowania opisane w~podrozdziale \ref{zwinne_testowanie}. Jak powszechnie wiadomo, testowanie gruntowne nie jest możliwe, jakiejkolwiek metody by nie użyto. Lecz ryzyko znalezienia błędu na dalszym etapie projektu jest w~tym przypadku znacznie większe niż w~przypadku oprogramowania o~usystematyzowanej strukturze, a~co za tym idzie – koszty jego usunięcia są również znacznie wyższe.

Okazuje się, że strukturę aplikacji Android da się jednak przeprojektować tak, aby ułatwić pracę zarówno programistom jak i~testerom. Propozycja zmiany struktury aplikacji Android zaproponowana została w~rozdziale \ref{clean_architecture}

\section{Przyczyny rezygnacji z~testów jednostkowych}
\label{testy_jednostkowe_brak}
Trudna w~testowaniu struktura aplikacji to jednak nie jedyna przyczyna niedostatecznej ilości testów jednostkowych, a~nawet ich braku w~procesie tworzenia aplikacji. Przyczyn takiej sytuacji może być wiele, a~do najważniejszych z~nich można zaliczyć:
\begin{itemize}
\item
Niedostateczną znajomość języka programowania wśród programistów;

Jeżeli programista został zmuszony przez sytuację do poznawania nowego języka programowania, to w~pierwszej kolejności chciałby, aby jego kod się kompilował, a~program zaczął działać. Jeżeli zaczyna pisać testy, to znaczy, że ma na to czas i~nie musi zagłębiać się w~techniki konfiguracji kompilatora, czy środowiska programistycznego. 

\item
Słabą znajomość narzędzi testowych;

Jeżeli programista nie doskonali się w~temacie projektowania testów, nie poznaje narzędzi testowych, które mogą spowodować, że testowanie stanie się łatwe, szybko zniechęci się już przy pierwszej próbie napisania trudniejszego testu.

\item
Niską jakość kodu źródłowego;

Kiepsko zaprojektowany kod i~nieoptymalnie zaprojektowana architektura systemowa powoduje, że nie ma możliwości w~rozsądnym czasie przygotować zestawu testów. To powoduje, że firmy rezygnują z~testów jednostkowych na rzecz testów integracyjnych i~systemowych, co pokazane zostało na rysunku \ref{fig:odwrocona_piramida}.

\item
Brak czasu na testy;

W dzisiejszych czasach koszty projektów informatycznych są zwykle ograniczone. W~związku z~tym programiści starają się wykorzystywać cały swój czas aż do terminu oddania swojej części programu na "ulepszanie" kodu, co skutkuje brakiem czasu na testy jednostkowe.

\item
Przekonanie programistów o~własnej nieomylności.

Człowiek jest omylny i~popełnia błędy, do czego nawiązano już w~rozdziale \ref{czy_testowanie_potrzebne}. Niektórzy programiści nie chcą jednak przyjąć tego do wiadomości i~upierają się przy stwierdzeniach, że testy do ich kawałka kodu źródłowego nie są potrzebne.
\end{itemize}

\section{Zwinne podejście do testowania}
\label{zwinne_testowanie}
\subsection{Wytwarzanie sterowane testowaniem}
\label{test_driven_development}
Technika wytwarzania sterowanego zarządzaniem (\textit{Test Driven Development}) zyskuje coraz więcej popularności. Związane to jest pośrednio z~nowymi modelami zarządzania projektami informatycznymi opartymi na metodykach zwinnych, w~tym Agile\footnote{Agile software development – grupa metodyk wytwarzania oprogramowania opartego na programowaniu iteracyjno-przyrostowym, powstałe jako alternatywa do tradycyjnych metod typu \textit{waterfall\footnote{Iteracyjny model kaskadowy (ang. waterfall model) – jeden z~kilku rodzajów procesów tworzenia oprogramowania zdefiniowany w~inżynierii oprogramowania. Polega on na wykonywaniu podstawowych czynności jako odrębnych faz projektowych, w~porządku jeden po drugim. Każda czynność to kolejny schodek (kaskada). Jeśli któraś z~faz zwróci niesatysfakcjonujący produkt, należy się cofnąć wykonując kolejne iteracje aż do momentu kiedy otrzymano satysfakcjonujący produkt na końcu schodków \cite{website:wikipedia}.}}. Najważniejszym założeniem metodyk zwinnych jest obserwacja, że wymagania odbiorcy (klienta) często ewoluują podczas trwania projektu. Oprogramowanie wytwarzane jest przy współpracy samozarządzalnych zespołów, których celem jest przeprowadzanie procesów wytwarzania oprogramowania \cite{website:wikipedia}.}. W~założeniu podejście takie pozwala:

\begin{itemize}
\item wyszukać więcej błędów na wcześniejszym etapie procesu programowania;
\item świadomie zaimplementować zmiany wtedy, kiedy są potrzebne;
\item wykonać testy regresywne bazując na wcześniej napisanych procedurach;
\item przedłużyć żywotność kodu.
\end{itemize}

Jeżeli istnieją testy jednostkowe i~pokrywają znaczącą część kodu źródłowego (70~-~80\%), wtedy jasne jest, że~więcej błędów zostanie znalezionych i~poprawionych. W~ten sam sposób przy podejściu \textit{Test Driven Development (TDD)} można wywnioskować, że skoro unit testy są już napisane, z~dużym prawdopodobieństwem pokrycie kodu będzie zadowalające. Co więcej, raz napisane testy można wykorzystywać do przeprowadzania testów regresywnych, aby się upewnić, czy zmiany w~oprogramowaniu zgodne są z~założeniami i~wymaganiami systemu.

Testy jednostkowe w~podejściu \textit{TDD} zapewniają, że jakość oprogramowania nie jest oparta na domysłach i~przekonaniu programistów, a~na rzetelnych raportach. Bez obaw można dokonywać modyfikacji jak zmiana serwera baz danych, zmiana modelu, czy interfejsu użytkownika. Jeżeli wszystkie testy zostaną sprawdzone pozytywnie - oprogramowanie będzie działać nadal bezbłędnie.

Ponadto TDD zmusza developera, żeby napisał tylko tyle linijek kodu, ile jest niezbędne dla powstania i~działania danej fukcjonalności. Nie ma tu miejsca na wymyślanie własnych ścieżek i~innowacji. Należy trzymać się prostych rozwiązań tak mocno, jak to możliwe, a~co za tym idzie nie komplikować niepotrzebnie aplikacji.

Z powyższego można wnioskować, że podejście \textit{TDD} może znacznie pomóc w~zwiększeniu testowalności i~pielęgnowalności aplikacji. 

\subsection{Wytwarzanie sterowane zachowaniem - \textit{Behaviour Driven Development}}
\label{behaviour_driven_development}
BDD do kolejna technika testowania mająca swoje korzenie w~metodykach zwinnych. Wywodzi się bezpośrednio z~opisywanej wcześniej TDD, a~także  nawiązuje pośrednio do techniki \textit{Acceptance Test Driven Development} (ATDD), opisanej w~skrócie w~sekcji \ref{alternatywne_metody_testowania}.

BDD rozszerza TDD o~następujące elementy:
\begin{itemize}
\item
Wprowadza zasadę "pięciu pytań \textit{Dlaczego}" dla każdego proponowanego przypadku użycia (\textit{user story}). W~ten sposób łatwiej jest ustalić rzeczywisty cel biznesowy;

\item
Stosuje strategię myślenia "z zewnątrz do wewnątrz", czyli programowania tylko tego, co jest rzeczywiście potrzebne z~punktu widzenia biznesowego;

\item
Wprowadza jednoznaczny opis zachowania, tak aby z~tej samej dokumentacji lub notatki mogli korzystać zarówno programiści, jak i~testerzy i~eksperci systemowi;

\item
Ten sposób działania wprowadzany jest od najwyższego (wymagania użytkownika) aż do najniższego (wymagania funkcjonalne) poziomu abstrakcji.

\end{itemize}

Dokumentacja w~podejściu BDD oparta jest w~znacznej mierze na przypadkach użytkownika (\textit{user stories}). Oczywiście na niższych poziomach abstrakcji muszą one być odpowiednio uszczegółowione.

Główna różnica pomiędzy TDD a~BDD jest więc taka, że TDD odnosi się do testów, a~BDD do scenariuszy użycia, lub innych przypadków opisanych za pomocą charakterystycznych dla \textit{Behaviour Driven Development} form \textit{Given-When-Then\footnote{GWT - forma tworzenia specyfikacji na podstawie przykładów}} (GWT).

Wszystkie te elementy powinny doprowadzić do zwiększonej współpracy programistów, testerów oraz specjalistów i~ekspertów dziedzinowych. Zamiast terminu "testy jednostkowe", zwolennicy BDD wolą używać "specyfikacja zachowania klasy", a~zamiast "testy funkcjonalne" - "specyfikacja zachowania produktu".

Stosowanie techniki \textit{Behaviour Driven Development} nie wymaga żadnych specjalnych narzędzi ani języków programowania. Jest to podejście czysto koncepcyjne \cite{website:agile:guide}.

\subsection{Alternatywne techniki testowania}
\label{alternatywne_metody_testowania}
TDD i~BDD to nie jedyne strategie testowania, które można przyjąć zwiększając testowalność aplikacji Androidowych. Warto wspomnieć również o~może nie tak popularnej, ale równie skutecznej strategii dotyczącej szczególnie testów akceptacyjnych, a~jest nią \textit{Acceptance Test-Driven Development} (ATDD). Jest to metodologia rozwoju opartego na komunikacji między klientami biznesowymi, programistami i~testerami. 

ATDD to inne podejście do testów akceptacyjnych, opisanych w sekcji \ref{testy_akceptacyjne}. Zasadniczo ATDD polega na wspólnym definiowaniu i automatyzowaniu testów akceptacyjnych jeszcze przed rozpoczęciem fazy implementacji. Zamiast sprawdzania, czy aplikacja działa zgodnie z założeniami klienta w końcowej fazie rozwoju, ATDD aktywnie uczestniczy w procesie tworzenia od samego początku. Za testy akceptacyjne w tym podejściu nie jest już odpowiedzalny tylko dział jakości, a stają się one wspólnym przedsięwzięciem, w które zaangażowani są właściciele produktu, analitycy biznesowi, testerzy i programiści. Zamiast typowego badania zgodności systemu z założeniami, ATDD pomaga zapewnić, że wszyscy członkowie projektu już na samym początku zrozumieli dokładnie założenia systemu. Ponadto, testy akceptacyjne planowane w wyżej wymieniony sposób, mogą zostać zautomatyzowane i zintegrowane w procesie rozwoju oprogramowania. Dzięki temu znalezione niezgodności mogą być skorygowane szybciej i mniej kosztownie.

Analizując jeszcze głębiej metodyki zwinne, możemy doszukać się również podejść \textit{Example Driven Development} (EDD) oraz \textit{Story test-Driven Development} (SDD). Różnice między nimi a~\textit{TDD} są tak niewielkie, że pominięto ich szczegółowy opis sygnalizując tylko, że zastosowanie takich taktyk testowania również może mieć wpływ na poprawienie testowalności aplikacji pod Androidem.  

%\section{Testowalność aplikacji androidowych}
%Z obserwacji autora wynika, że bardzo łatwo jest napisać zły i~nietestowalny kod dla Androida. Warto jednak pamiętać, że zastosowanie procesów z~metodologii wymienionych w~poprzednich podrozdziałach zdecydowanie może podnieść testowalność aplikacji pisanych dla tego systemu. Techniki te znacznie pomagają programistom i~testerom w~zrozumieniu potrzeb klienta.

%Ale czy zastosowanie metody \textit{TDD} lub \textit{BDD} jest wystarczające, aby podnieść testowalność aplikacji Android? Czy może potrzebna jest zmiana całej struktury aplikacji? Jak dzielić odpowiedzialność pomiędzy częściami oprogramowania? Jak rozwiązać problem zbyt dużego sprzężenia zarówno w~napisanym kodzie, jak i~pomiędzy kodem aplikacji i~frameworkiem androidowym \footnote{Sprzężenie (\textit{ang. coupling}) jest miarą jak bardzo obiekty, podsystemy lub systemy zależą od siebie nawzajem.}? Oraz najważniejsze pytanie: jak testować aplikacje dla Androida skutecznie?

%Na te pytania autor postara się odpowiedzieć w~dalszej części pracy.
%tutaj przykłady jak użyć poszczególnych konstrukcji
%Przykładowy rysunek \ref{fig:sample_figure}. Prztykładowa tabela %\ref{tab:sample_table}. Przykładowy odnośnik do bibliografi \cite{bib:kowalski_2015}. \textbf{Powodzenia!}


%\begin{figure}[!htb]
%    \centering
%    \includegraphics[width=10cm]{imgs/sample_figure.jpg}
%    \caption{Przykłady rysunek}
%    \label{fig:sample_figure}
%\end{figure} 

%\begin{table}[]
%\centering
%\caption{Przykładowa tabela}
%\label{tab:sample_table}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Nazwa} & \textbf{Wartość} \\ \hline
%Test           & 1.2              \\ \hline
%Kwiatek        & 5                \\ \hline
%\end{tabular}
%\end{table}